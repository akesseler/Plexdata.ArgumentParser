<!DOCTYPE html>
<html>
<head>
<title>Plexdata Argument Parser</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
    font-family: "Calibri", sans-serif;
}
.navbar {
    height: 100%;
    width: 190px;
    position: fixed;
    z-index: 1;
    top: 0;
    left: 0;
    background-color: #262626;
    overflow-x: hidden;
    padding-top: 20px;
}
.navbar .navsub {
    font-size: 1.2em;
    margin-left: 1em;
}
.navbar a {
    padding: 3px 8px 3px 16px;
    text-decoration: none;
    font-size: 1.6em;
    color: #818181;
    display: block;
}
.navbar a:hover {
    color: #F1F1F1;
}
.content {
    margin-left: 190px;
    font-size: 1.4em;
    padding: 10px 50px;
}
code {
  font-family: "Consolas", monospace;
}
pre {
    padding: 20px;
    font-size: 0.7em;
    background-color: #FCFCFC;
    border: 1px solid #C4C4C4;
    overflow-x: auto;
}
table {
    width: 100%;
}
th {
    background-color: #EDEDED;
    color: #636363;
}
table, th, td {
    border-top: 1px solid #C4C4C4;
    border-bottom: 1px solid #C4C4C4;
    border-collapse: collapse;
}
th, td {
    padding: 10px;
    text-align: left;
    vertical-align: top;
}
tbody tr:nth-child(odd){
    background-color: #FCFCFC;
}
p a {
    text-decoration: none;
}
p a:hover {
    text-decoration: underline;
}
</style>
</head>
<body>
<div class="navbar">
  <a href="#overview">Overview</a>
  <a href="#licensing">Licensing</a>
  <a href="#installation">Installation</a>
  <a href="#declaration">Declaration</a>
    <a href="#declaration-switch" class="navsub">Switch</a>
    <a href="#declaration-option" class="navsub">Option</a>
    <a href="#declaration-verbal" class="navsub">Verbal</a>
  <a href="#usage">Usage</a>
    <a href="#usage-switch" class="navsub">Switch</a>
    <a href="#usage-option" class="navsub">Option</a>
    <a href="#usage-verbal" class="navsub">Verbal</a>
    <a href="#usage-parsing" class="navsub">Parsing</a>
    <a href="#usage-problem" class="navsub">Problem</a>
  <a href="#dependencies">Dependencies</a>
    <a href="#dependencies-explicit" class="navsub">Explicit</h3>
    <a href="#dependencies-implicit" class="navsub">Implicit</h3>
    <a href="#dependencies-mutual" class="navsub">Mutual</h3>
  <a href="#help">Help</a>
  <a href="#limitation">Limitation</a>
</div>
<div class="content">
  
<header><center><h1>Plexdata Argument Parser</h1></center></header> 

<h2 id="overview">Overview</h2>

<p>
The <i>Plexdata Argument Parser</i> is a library that allows users to easily parse the command 
line arguments given to a program. The main feature of this library is that users only need to 
define their own class representing all possible command line arguments. Thereafter, each of the 
properties is tagged by an attribute which describes the type of the expected command line argument.
</p>
<p>
At runtime an instance of this pre&#8209;defined class is consigned to the <i>Plexdata Argument Parser</i> 
together with the actual command line arguments. After the parsing procedure the class contains the values 
that have been assigned by command line.
</p>
<p>
Another feature of the <i>Plexdata Argument Parser</i> is the possibility of an automated generation 
of a program&rsquo;s help text. For this purpose the pre&#8209;defined class is tagged by a suitable 
set of attributes that include all information needed to generate the help text.
</p>

<h2 id="licensing">Licensing</h2>

<p>
The software has been published under the terms of
</p>

<h3>MIT License</h3>

<p>
Copyright &copy; 2019 <a target="_blank" href="http://www.plexdata.de/">plexdata.de</a>
</p>
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
associated documentation files (the "Software"), to deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject 
to the following conditions:
</p>
<p>
The above copyright notice and this permission notice shall be included in all copies or substantial 
portions of the Software.
</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED 
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.
</p>

<h2 id="installation">Installation</h2>

<p>
The binary files of the <i>Plexdata Argument Parser</i> are provided as <i>NuGet</i> package and can be obtained from 
<a target="_blank" href="https://www.nuget.org/packages/Plexdata.ArgumentParser.NET/">https://www.nuget.org/packages/Plexdata.ArgumentParser.NET</a>. 
How to install this <i>NuGet</i> package manually is explained there.
</p>
<p>
Using the <i>Plexdata Argument Parser</i> together with <i>Visual Studio</i>.
</p>
<ul>
<li>
Create a new <i>.NET Framework</i> project.
</li>
<li>
Open menu <i>Tools &rarr; NuGet Package Manager</i> and choose command <i>Manage NuGet Packages for Solution&hellip;</i>.
<ul>
<li>
Alternatively, simply right&#8209;click the project in the <i>Solution Explorer</i> and choose command <i>Manage NuGet Packages&hellip;</i>.
</li>
</ul>
</li>
<li>
Switch to <i>Browse</i> page and in the search box just type <code>plexdata.argument</code>.
</li>
<li>
From the shown list select <i>Plexdata.ArgumentParser.NET</i> and click button <code>[Install]</code> at the right.
</li>
<li>
Confirm the dialog box and that&rsquo;s it.
</li>
</ul>
<p>
Additionally, all releases can be downloaded from <i>GitHub</i>. Please visit page 
<a target="_blank" href="https://github.com/akesseler/Plexdata.ArgumentParser/releases">Plexdata Argument Parser</a> 
to find all available versions.
</p>

<h2 id="declaration">Declaration</h2>

<p>
A class that shall serve as representation of supported command line arguments should consist of a set 
of properties. Each of these properties must have a public setter as well as a public getter. All other 
properties, fields and/or methods are ignored.
</p>
<p>
Furthermore, all in all three different types of command line arguments are supported. These three different 
types are called <i>Switch</i>, <i>Option</i> and <i>Verbal</i> arguments.
</p>

<h3 id="declaration-switch">Switch</h3>

<p>
<i>Switches</i> are command line arguments that either can be &ldquo;on&rdquo; or &ldquo;off&rdquo;. In other 
words, <i>Switches</i> represent some kind of <i>Boolean</i> type. One typical representative of this type of 
command line argument is for example the argument <code>&#8209;&#8209;verbose</code>. A command line argument 
class can have multiple <i>Switch</i> types.
</p>

<h3 id="declaration-option">Option</h3>

<p>
<i>Options</i> are command line arguments that include additional information. Such kind of command line argument 
is for example the argument <code>&#8209;&#8209;username</code>, because of this argument type requires that a user 
name has to be specified. Otherwise a login can&rsquo;t be performed for instance. A command line argument class can 
have multiple <i>Option</i> types.
</p>

<h3 id="declaration-verbal">Verbal</h3>

<p>
<i>Verbal</i> arguments are types that don&rsquo;t have a name. Furthermore, such kind of command line argument 
may consist of multiple values. A typical representative of this type is for example a list of files to be processed. 
A command line argument class can have only one <i>Verbal</i> type.
</p>

<h2 id="usage">Usage</h2>

<p>
Task of this section is to show how the <i>Plexdata Argument Parser</i> can be used to configure a class that 
shall serve as command line argument representation.
</p>

<h3 id="usage-switch">Switch</h3>

<p>
As mentioned above, a program that wants to use on/off arguments should be configured as demonstrated below.
</p>
<pre><code>[ParametersGroup]
class CmdLineArgs
{
    [SwitchParameter(SolidLabel = "verbose", BriefLabel = "v")]
    public Boolean IsVerbose { get; set; }

    [SwitchParameter(SolidLabel = "debug")]
    public Boolean IsDebug { get; set; }
}</code></pre>
<p>
As shown above, each property is of type <i>Boolean</i> and provides a public setter as well as a public getter 
for those properties. Further, each of these properties is tagged by an attribute named <code>SwitchParameter</code>. 
The <code>SolidLabel</code> of each switch parameter defines the long name of the command line argument. Long 
name command line arguments are typically prefixed by a double&#8209;dash.
</p>
<p>
Additionally, property <code>IsVerbose</code> uses a <code>BriefLabel</code> as well. A brief label typically 
represents an abbreviation of the long argument and is usually prefixed by a single&#8209;dash at command line.
</p>
<p>
In contrast to that, property <code>IsDebug</code> only uses the <code>SolidLabel</code> which in turn means that 
only the long name is available as command line argument.
</p>
<p>
With this class in background, users can for instance call the program as shown as follows.
</p>
<pre><code>$&gt; program.exe --verbose --debug
$&gt; program.exe -v --debug
$&gt; program.exe --verbose
$&gt; program.exe -v
$&gt; program.exe --debug</code></pre>

<h3 id="usage-option">Option</h3>

<p>
As mentioned above, a program that wants to use arguments with additional data should be configured as 
demonstrated below.
</p>
<pre><code>[ParametersGroup]
class CmdLineArgs
{
    [OptionParameter(SolidLabel = "password", DependencyList = "Username")]
    public String Password { get; set; }

    [OptionParameter(SolidLabel = "username", DependencyList = "Password")]
    public String Username { get; set; }
}</code></pre>
<p>
As shown above, each of the <i>Option</i> attributes include a <i>DependencyList</i> tag. Task of this tag 
is to ensure that each of the command line arguments tagged this way are provided when a program is called.
</p>
<p>
This in detail means that if one of the arguments is provided without the other one than the parser throws 
an exception to inform that a rule check has failed.
</p>
<p>
With this class in background, users can for instance call the program as shown as follows.
</p>
<pre><code>$&gt; program.exe --username &lt;username&gt; --password &lt;password&gt;
$&gt; program.exe --password &lt;password&gt; --username &lt;username&gt;</code></pre>
<p>
Additionally, it is possible to use default values for optional parameters. How to use them is shown in 
the next example.
</p>
<pre><code>[ParametersGroup]
class CmdLineArgs
{
    [OptionParameter(SolidLabel = "host", DefaultValue = "http://example.org")]
    public String Host { get; set; }

    [OptionParameter(SolidLabel = "port", DefaultValue = 12345)]
    public UInt16 Port { get; set; }
}</code></pre>
<p>
Here are some rules of how to use this feature. Each default value can be applied as type&ndash;save 
constant value and as string literal as well for all of the supported types. An exception of type 
<code>DefaultValueException</code> is thrown if applying a default value fails for any reason. Default 
values are replaced by the argument parser as soon as they are provided as command line argument.
</p>

<h3 id="usage-verbal">Verbal</h3>

<p>
As mentioned above, a program that wants to use for example a list of files as arguments, then it would be 
configured as demonstrated below.
</p>
<pre><code>[ParametersGroup]
class CmdLineArgs
{
    [VerbalParameter]
    public String[] Files { get; set; }
}</code></pre>
<p>
As shown above, the <i>Verbal</i> attribute is used for such a purpose. In contrast to the usage of 
<i>Switches</i> and/or <i>Options</i>, the usage of <i>Verbal</i> attributes is limited to one per class. 
Otherwise a rule check exception is thrown by the parser.
</p>
<p>
With this class in background, users can for instance call the program as shown as follows.
</p>
<pre><code>$&gt; program.exe file1.txt
$&gt; program.exe file1.txt file2.txt
$&gt; program.exe file1.txt file2.txt file3.txt</code></pre>

<h3 id="usage-parsing">Parsing</h3>
<p>
Once a proper class has been implemented, the program&rsquo;s main method can parse a given list of 
command line arguments as shown below.
</p>
<pre><code>static void Main(string[] args)
{
    try
    {
        if (args.Length > 0)
        {
            CmdLineArgs cmdLineArgs = new CmdLineArgs();
            cmdLineArgs.Process(args);
        }
    }
    catch (Exception exception)
    {
        Console.WriteLine(exception.Message);
    }
}</code></pre>
<p>
As shown above, it is strictly recommended to surround any call to the command line parser by a 
<code>try&hellip;catch</code> block.
</p>

<h3 id="usage-problem">Problem</h3>

<p>
There is a known issue while parsing a program&rsquo;s arguments and it comes to light when using the 
<code>args</code> array that is provided as parameter of the <code>Main()</code> method. 
</p>

<p>
The meant issue gets visible as soon as using arguments that are surrounded by double&#8209;quotes 
and a backslash is included right before the closing double&#8209;quote. See below for such an example.
</p>

<pre><code>$&gt; program.exe -o -p "*.xyz" -s "c:\folder1\" -t "c:\folder2\" -v</code></pre>

<p>
Is this particular case the provided arguments are split into an array that looks like the one shown as 
next.
</p>

<pre><code>[0]: "-o"
[1]: "-p"
[2]: "*.xyz"
[3]: "-s"
[4]: "c:\\folder1\" -t c:\\folder2\""
[5]: "-v"</code></pre>

<p>
The mistake is in line [4] of the above example. The <i>.NET Framework</i> parser did interpret each 
occurrence of a backslash and double&#8209;quote combination as an escaped double&#8209;quote character, 
which was indeed not meant in this context. But the <i>Plexdata Argument Parser</i> provides a workaround 
allowing to prevent such an unwanted behavior. See next code snippet how to use this workaround.
</p>

<pre><code>static void Main(string[] args)
{
    try
    {
        // Use the string extension method Extract() of package 
        // Plexdata Argument Parser as alternative command line 
        // argument parser.
        <strong>string[] options = Environment.CommandLine.Extract();</strong>
        if (options != null && options.Length &gt; 0)
        {
            // Maybe remove first array line because it just 
            // contains the path of the calling executable.
            CmdLineArgs cmdLineArgs = new CmdLineArgs();
            cmdLineArgs.Process(options);
            cmdLineArgs.Validate();
        }
    }
    catch (Exception exception)
    {
        Console.WriteLine(exception.Message);
    }
}</code></pre>

<h2 id="dependencies">Dependencies</h2>

<p>
This feature allows making an argument depends on another argument or a list of arguments. At the 
moment there exist three types of dependencies; explicit, implicit and mutual dependencies. This section 
wants to clarify how to use the dependency feature of the <i>Plexdata Argument Parser</i>.
</p>
<p>
At this point it is important to know, the parameter <code>DependencyList</code> of any of the attributes 
always takes a list property names! The parameter <code>DependencyList</code> does neither accept the 
<code>SolidLabel</code> nor the <code>BriefLabel</code> as value.
</p>

<h3 id="dependencies-explicit">Explicit Dependency</h3>

<p>
The term of an <i>Explicit Dependency</i> means that one argument depends on another argument or a list of arguments. 
A good example of this kind of dependency is the argument combination of <code>&#8209;&#8209;file&#8209;name</code>, 
<code>&#8209;&#8209;operation</code> and <code>&#8209;&#8209;execution</code>. In other words, the argument 
<code>&#8209;&#8209;file&#8209;name</code> requires the type of operation as well as the type of execution, 
but not the other way round.
</p>

<h4 id="dependencies-explicit-strong">Strong Explicit Dependency</h4>

<p>
The <i>Strong Explicit Dependency</i> means in detail that all referenced arguments are required to satisfy 
the needs of the source argument. The other way round, the <i>Strong Explicit Dependency</i> combines all referenced 
arguments with an AND operation. How to configure such kind of dependency is shown in code snippet below.
</p>
<pre><code>[ParametersGroup]
class CmdLineArgs
{
    [OptionParameter(SolidLabel = "file-name", DependencyList = "Operation, Execution", DependencyType = DependencyType.Required)]
    public String Filename { get; set; } // 'Filename' depends on 'Operation' and 'Execution'.

    [OptionParameter(SolidLabel = "operation", DependencyList = "Filename", DependencyType = DependencyType.Optional)]
    public String Operation { get; set; } // 'Operation' cannot be used without 'Filename'.

    [OptionParameter(SolidLabel = "execution", DependencyList = "Filename", DependencyType = DependencyType.Optional)]
    public String Execution { get; set; } // 'Execution' cannot be used without 'Filename'.
}</code></pre>
<p>
With the above class in mind, a program execution will only be possible like shown as follows.
</p>
<pre><code>$&gt; program.exe --file-name file-name.ext --execution execution-value --operation operation-value</code></pre>

<h4 id="dependencies-explicit-weak">Weak Explicit Dependency</h4>

<p>
The <i>Weak Explicit Dependency</i> combines all referenced arguments with an AND operation as well. But in 
contrast to the <i>Strong Explicit Dependency</i>, the <i>Weak Explicit Dependency</i> allows a usage of the 
referenced arguments independently of the source argument. How to configure this kind of dependency is shown 
in code snippet below.
</p>
<pre><code>[ParametersGroup]
class CmdLineArgs
{
    [OptionParameter(SolidLabel = "file-name", DependencyList = "Operation, Execution", DependencyType = DependencyType.Required)]
    public String Filename { get; set; } // 'Filename' depends on 'Operation' and 'Execution'.

    [OptionParameter(SolidLabel = "operation")]
    public String Operation { get; set; } // 'Operation' can be used without 'Filename'.

    [OptionParameter(SolidLabel = "execution")]
    public String Execution { get; set; } // 'Execution' can be used without 'Filename'.
}</code></pre>
<p>
With the above class in mind, a program execution will be possible like shown below.
</p>
<pre><code>$&gt; program.exe --operation operation-value
$&gt; program.exe --execution execution-value
$&gt; program.exe --operation operation-value --execution execution-value
$&gt; program.exe --file-name file-name.ext --execution execution-value --operation operation-value</code></pre>

<h3 id="dependencies-implicit">Implicit Dependency</h3>

<p>
The term of an <i>Implicit Dependency</i> also means that one argument depends on another argument or a list of 
arguments. But in contrast to an <i>Explicit Dependency</i> relation, an <i>Implicit Dependency</i> turns around 
the referencing direction. This in fact makes it possible to combine the source argument with its dependent 
arguments by an OR operation. The same example as above can be used right here as well to show how this kind 
of dependency works.
</p>

<h4 id="dependencies-implicit-strong">Strong Implicit Dependency</h4>

<p>
The <i>Strong Implicit Dependency</i> means in detail that only a subset of all referenced arguments is required 
to satisfy the needs of the source argument. As mentioned above, the <i>Strong Implicit Dependency</i> combines all 
referenced arguments with an OR operation. How to configure such kind of dependency is shown in code snippet below.
</p>
<pre><code>[ParametersGroup]
class CmdLineArgs
{
    [OptionParameter(SolidLabel = "file-name", DependencyList = "Operation, Execution", DependencyType = DependencyType.Optional)]
    public String Filename { get; set; } // 'Filename' depends on 'Operation' or 'Execution'.

    [OptionParameter(SolidLabel = "operation", DependencyList = "Filename", DependencyType = DependencyType.Required)]
    public String Operation { get; set; } // 'Operation' cannot be used without 'Filename'.

    [OptionParameter(SolidLabel = "execution", DependencyList = "Filename", DependencyType = DependencyType.Required)]
    public String Execution { get; set; } // 'Execution' cannot be used without 'Filename'.
}</code></pre>
<p>
With the above class in mind, a program execution will be possible as shown here.
</p>
<pre><code>$&gt; program.exe --file-namefile-name.ext --operation operation-value
$&gt; program.exe --file-name file-name.ext --execution execution-value
$&gt; program.exe --file-name file-name.ext --execution execution-value --operation operation-value</code></pre>

<h4 id="dependencies-implicit-weak">Weak Implicit Dependency</h4>

<p>
Some readers may already guess, the difference between a <i>Strong Implicit Dependency</i> and the <i>Weak Implicit Dependency</i> 
is that an independent usage of the referenced arguments becomes possible. No, unfortunately not! 
</p>
<p>
But it becomes possible to use the source argument (<code>&#8209;&#8209;file&#8209;name</code> in the example above) without 
of any of the referenced arguments. See following code snippet for an example of how to configure this kind of dependency.
</p>
<pre><code>[ParametersGroup]
class CmdLineArgs
{
    [OptionParameter(SolidLabel = "file-name")]
    public String Filename { get; set; } // 'Filename' depends on 'Operation' or 'Execution'.

    [OptionParameter(SolidLabel = "operation", DependencyList = "Filename", DependencyType = DependencyType.Required)]
    public String Operation { get; set; } // 'Operation' cannot be used without 'Filename'.

    [OptionParameter(SolidLabel = "execution", DependencyList = "Filename", DependencyType = DependencyType.Required)]
    public String Execution { get; set; } // 'Execution' cannot be used without 'Filename'.
}</code></pre>
<p>
With the above class in mind, a program execution will be possible as shown here.
</p>
<pre><code>$&gt; program.exe --file-name file-name.ext 
$&gt; program.exe --file-name file-name.ext --operation operation-value 
$&gt; program.exe --file-name file-name.ext --execution execution-value 
$&gt; program.exe --file-name file-name.ext --execution execution-value --operation operation-value</code></pre>

<h3 id="dependencies-mutual">Mutual Dependency</h3>

<p>
The term of a <i>Mutual Dependency</i> does actually mean that one argument depends on another argument and vice 
versa. A good example of this kind of dependency is the argument combination of <code>&#8209;&#8209;username</code> 
and <code>&#8209;&#8209;password</code>, because a user name does not make any sense without having a password.
</p>
<p>
How to configure such kind of dependency is shown in the example in section <a href="#usage-option">Option</a>. 
Therefore, there is no need to explain it again right here. The only thing to mention in this section is that a 
cross reference is already applied by using the reference name of one property within the list of dependencies 
of the other property, and vice versa.
</p>

<h2 id="help">Help</h2>

<p>
The <i>Plexdata Argument Parser</i> is also able to generate a command line help text. For this purpose 
a class that describes all possible command line arguments should be configured with additional attributes. 
Here an example.
</p>
<pre><code>[HelpLicense]
[HelpUtilize]
[HelpPreface("This program does something useful.")]
[ParametersGroup]
class CmdLineArgs
{
    [HelpSummary("More output during runtime.")]
    [SwitchParameter(SolidLabel = "verbose", BriefLabel = "v")]
    public Boolean IsVerbose { get; set; }

    [HelpSummary("Run program in Debug mode.")]
    [SwitchParameter(SolidLabel = "debug")]
    public Boolean IsDebug { get; set; }
}</code></pre>
<p>
Parsing the help text and printing it out could be done as shown below.
</p>
<pre><code>static void Main(string[] args)
{
    try
    {
        CmdLineArgs cmdLineArgs = new CmdLineArgs();
        Console.WriteLine(cmdLineArgs.Generate());
        Console.ReadKey();
    }
    catch (Exception exception)
    {
        Console.WriteLine(exception.Message);
    }
}</code></pre>
<p>
For the above example, the help screen shown to the user would look like shown below.
</p>
<pre><code>Copyright &copy; &lt;company&gt;

This program does something useful.

Usage:

  &lt;program&gt; [options]

Options:

  --verbose [-v]  More output during runtime.

  --debug         Run program in Debug mode.</code></pre>
<p>
For sure, this is a pretty simple example. In other words, the help generator is able to do more. 
For example it is possible to take some of the &ldquo;properties&rdquo; from the executing assembly 
and put them into the help text. The help usage part as well as the help option section can be 
grouped and so on.
</p>

<h2 id="limitation">Limitation</h2>

<p>
Not known at the moment.
</p>

</div>
</body>
</html> 
